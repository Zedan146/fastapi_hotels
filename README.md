## Запуск проекта

1. Создать виртуальное окружение ```python -m venv .venv```
2. Активировать виртуальное окружение `source .venv/bin/activate`
3. Установить зависимости `pip install -r requriments.txt`
4. Создать файл .env и указать в нем:

#### Настройки БД

- DB_HOST='Адрес вашей БД'
- DB_PORT='Порт вашей БД'
- DB_USER='Имя пользователя'
- DB_PASS='Ваш пароль'
- DB_NAME='Имя БД'

#### Настройки для JWT токена

- JWT_SECRET_KEY='Ваш секретный ключ'
  Как и где его сгенерировать смотреть тут
- JWT_ALGORITHM='Ваш алгоритм обработки токена'
- ACCESS_TOKEN_EXPIRE_MINUTES='Время экспирации токена'

## Pydantic:

## SQLalchemy

## FastAPI

## Redis

**Redis** — это база данных формата **ключ: значение** в оперативной памяти, написанная на языке С. Redis можно
встретить в
проекте любого масштаба, причем чаще всего его можно встретить как инструмент для кэширования данных. Его также
используют для хранения сессий пользователей (для аутентификации), для пересылки данных сразу нескольким сервисам, как
очередь задач и пр.<br>

### Базовый функционал

```
127.0.0.1:6379> SET A 123 <-- эту команду вбил я
OK <-- такой ответ отдал Redis
127.0.0.1:6379> GET A
"123"
127.0.0.1:6379> KEYS *
1) "A"
127.0.0.1:6379> DEL A
(integer) 1
127.0.0.1:6379> GET A
(nil)
```

- SET - устанавливает ключу A значение 123, <br>
- GET - позволяет просмотреть значение ключа, <br>
- KEYS * - отдает список всех ключей (без значений), <br>
- DEL - удаляет ключ и соответствующее значение. <br>
- (nil) - в Redis аналогичен None в Python.

## Celery

**Celery** — это известная библиотека для выполнения фоновых задач. Celery используется на многих Python проектах
независимо от фреймворка Django/Flask/FastAPI.
Для хранения задач Celery использует брокеров, например, Redis или RabbitMQ.
Celery использует Redis как для хранения заданий, так и для хранения результатов выполнения задач.
Например, если мы обрабатываем видео или фото пользователя, генерируем отчет или конвертируем файл из docx в pdf,
мы хотим сохранять в Redis результаты выполнения заданий: в перечисленных случаях это будут ссылки на файлы, нужные
пользователю.
<br><br>
К примеру, в нашем приложении пользователь должен отправить картинку (которую нам нужно будет отредактировать, сохранить
в разных разрешениях, проверить на соответствие размерам и т.п.) и подтвердить адрес электронной почты. Если наше
приложение обрабатывает изображение, а потом отправляет письмо для подтверждения в обработчике запросов, то конечному
пользователю приходится зачем-то ждать завершения выполнения обеих задач перед тем, как закрыть страницу. Вместо этого,
мы можем передать эти операции в очередь задач и оставить на обработку отдельному процессу, чтобы немедленно отправить
пользователю ответ. В таком случае, конечный пользователь сможет заниматься другими делами на стороне во время
выполнения обработки задач сервером в фоновом режиме. Наше приложение в таком случае сможет свободно отвечать на запросы
других пользователей и клиентов.

## Тестирование Pytest

![testing_manual](https://habrastorage.org/r/w1560/webt/qz/lv/xu/qzlvxuwxpf5cocp0ryev46w7ax8.png)

Слово "стоимость" на схеме обозначает количество затраченных нервных клеток и единиц времени на их написание и
поддержку (да, порой тесты приходится переписывать).<br> Единственное, что не указано на этой схеме — порядок написания
тестов. Обычно первыми пишутся unit-тесты, затем API и интеграционные тесты, и лишь затем E2E тесты.

Давайте опишем, что каждый вид тестов:<br>

- Юнит-тесты тестируют одну единственную функцию в изоляции от других функций. Это значит, что этот тест никоим образом не
зависит от выполнения других тестов и от внешних систем (баз данных, API'шек, брокеров и т.п.)<br>

- Интеграционные тесты тестируют 2 и более функций в связке друг с другом. Тем не менее, этот тест также должен быть
изолирован от всех других тестов<br>

- API тесты, как понятно из названия, тестируют эндпоинты. Они больше относятся к интеграционным, так как обычно содержат
в себе несколько функций: получение, обработка и добавление данных, запуск фоновых задач и т.д.

- E2E (end-to-end) или сквозное тестирование применяется для проверки целых пользовательских сценариев. Например,
регистрация пользователя -> аутентификация (логин) -> просмотр списка отелей -> просмотр списка номеров в отеле ->
бронирование номера в отеле -> отправка сообщения на почту с информацией о бронировании. Такие тесты очень долго писать
и поддерживать

## Docker

## CI/CD

## Alembic

### Базовые команды Alembic:

```alembic init alembic``` - инициализация проекта миграций. (Будет создана папка alembic/ с файлами и alembic.ini).

```alembic revision --autogenerate -m "описание"``` - создание новой ревизии на основе моделей

```alembic upgrade head``` - применить последнюю миграцию

```alembic downgrade -1``` - откатить последнюю миграцию

## Теоретические сведения:

### Паттерн DataMapper:

**Шаблон Data Mapper** - это слой доступа к данным, который предоставляет двунаправленную работу с данными между БД и
хранением данных в памяти (например, на время выполнения кода). В его обязанности входит передача данных между объектами
и базой данных и изоляция их друг от друга. Если мы получаем средство отображения данных, объекту в памяти совершенно не
обязательно знать, существует база данных или нет.
<br>
Шаблон **Data Mapper** позволяет связать модель и схему без их взаимозависимости.<br> То есть модель не привязана к
схеме,
а схема - к модели.
<center>   

![datamapper_img](https://sajadtorkamani.com/wp-content/uploads/2022/08/image-1.png)

</center>

### Авторизация и аутентификация

- **Аутентификация** — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения
  введенного им пароля с паролем, сохраненным в базе данных.

- **Авторизация** — предоставление определенному лицу или группе лиц прав на выполнение определенных действий.

<center>   

![auth_img](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c42/aef/a21/c42aefa212088fb325bee52a5196b2dc.png)

</center>   

